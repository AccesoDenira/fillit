#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <time.h>
#include <unistd.h>
#include "libft.h"
#include "points.h"
#include "tetrimino.h"

void	print_tetrimno(t_tetri *tetri)
{
	int y;

	y = 0;
	while (y < tetri->height)
	{
		ft_putstr(tetri->shape[y++]);
		ft_putchar('\n');
	}
}

char *g_rshape_v1 = ".#..\n.#..\n.#..\n.#..\n";
char *g_rshape_i1 = ".#..\n.#..\n.#..\n...#\n";

char *g_rshape_v2 = ".##.\n..##\n....\n....\n";
char *g_rshape_i2 = ".#.#\n..##\n....\n....\n";

char *g_rshape_v3 = "##..\n##..\n....\n....\n";

#test invalid_map
	printf("CHECKING FOR INVALID MAP INPUT...\n");
	
	struct stat st;
	int bytes_written;
	FILE *fp;
	char *str;
	char *invalidfiles[] = {
		"test_input/invalid_maps/5x5",
		"test_input/invalid_maps/30tetriminoes",
		"test_input/invalid_maps/nonewlineatend",
		"test_input/invalid_maps/nopermissions",
		"test_input/invalid_maps/startswithnewline",
		"test_input/invalid_maps/stucktogether",
		"test_input/invalid_maps/toomanynewlines",
		NULL};

	bytes_written = 0;
	fp = freopen("./tests/redir.txt", "w+", stdout);
	int i = 0;
	while (invalidfiles[i])
	{
		//get_tetriminoes_from_file(invalidfiles[i]);
		i++;
	}
	stat("./tests/redir.txt", &st);
	bytes_written = st.st_size;
	//ck_assert_int_eq(bytes_written, strlen(sentence));
	str = (char *)malloc(sizeof(char) * bytes_written + 1);
	rewind(fp);
	fscanf(fp, "%s", str);
	//ck_assert_str_eq(str, sentence);
	fclose(fp);
	free(str);

	remove("./tests/redir.txt");

#test 	check_xy_to_len
	printf("CHECKING XY TO LEN...\n");

	ck_assert_int_eq(5, xy_to_len(0, 1));

#test	check_create_point
	printf("CHECKING CREATE POINT...\n");

	t_point	*point;

	point = create_point(0);
	ck_assert_int_eq(0, point->x);
	ck_assert_int_eq(0, point->y);
	point->x = 10;
	ck_assert_int_eq(10, point->x);
	free_point(&point);
	ck_assert_ptr_eq(0, point);

	point = create_point(6);
	ck_assert_int_eq(1, point->x);
	ck_assert_int_eq(1, point->y);
	free_point(&point);
	ck_assert_ptr_eq(0, point);

	point = create_point(1);
	ck_assert_int_eq(1, point->x);
	ck_assert_int_eq(0, point->y);
	ck_assert_int_eq(1, xy_to_len(point->x, point->y));
	ck_assert_int_eq(g_rshape_v1[1], g_rshape_v1[xy_to_len(point->x, point->y)]);
	free_point(&point);
	ck_assert_ptr_eq(0, point);

	point = create_point(5);
	ck_assert_int_eq(0, point->x);
	ck_assert_int_eq(1, point->y);
	free_point(&point);
	ck_assert_ptr_eq(0, point);

#test check_free_point
	printf("CHECKING FREE POINT...\n");

	t_point	*point;

	point = create_point(0);
	free_point(&point);
	ck_assert_ptr_eq(0, point);

#test check_free_minmax_points
	printf("CHECKING MINMAX FREE POINTS...\n");

	t_point	**points;
	
	points = (t_point **)ft_memalloc(sizeof(*points) * 2);
	points[0] = create_point(0);
	points[1] = create_point(3);
	ck_assert_ptr_ne(0, points);
	free_minmax_points(&points);
	//ck_assert_ptr_eq(0, points[0]);
	//ck_assert_ptr_eq(0, points[1]);
	ck_assert_ptr_eq(0, points);

#test check_validate_block
	printf("CHECKING VALIDATE BLOCK...\n");

	//char *g_rshape_v1 = ".#..\n.#..\n.#..\n.#..\n";
	//char *g_rshape_i1 = ".#..\n.#..\n.#..\n...#\n";

	//char *g_rshape_v2 = ".##.\n..##\n....\n....\n";
	//char *g_rshape_i2 = ".#.#\n..##\n....\n....\n";

	//char *g_rshape_v3 = "##..\n##..\n....\n....\n";

	int count = 0;
	int bl_v1[4] = {1, 6, 11, 16};
	int bl_i1[4] = {1, 6, 11, 18};
	int bl_v2[4] = {1, 2, 7, 8};
	int bl_i2[4] = {1, 3, 7, 8};
	int bl_v3[4] = {0, 1, 5, 6};

	while(count < 4)
		ck_assert_int_eq(1, validate_block(g_rshape_v1, bl_v1[count++]));
	count = 0;
	while(count < 3)
		ck_assert_int_eq(1, validate_block(g_rshape_i1, bl_i1[count++]));
	ck_assert_int_eq(0, validate_block(g_rshape_i1, bl_i1[count]));

	count = 0;
	while(count < 4)
		ck_assert_int_eq(1, validate_block(g_rshape_v2, bl_v2[count++]));
	count = 0;
	ck_assert_int_eq(0, validate_block(g_rshape_i2, bl_i2[count++]));
	while (count < 4)
		ck_assert_int_eq(1, validate_block(g_rshape_i2, bl_i2[count++]));

	count = 0;
	while(count < 4)
		ck_assert_int_eq(1, validate_block(g_rshape_v3, bl_v3[count++]));

#test check_validate_tetrimino
	printf("CHECKING VALIDATE TETRIMINO...\n");

	//char *g_rshape_v1 = ".#..\n.#..\n.#..\n.#..\n";
	//char *g_rshape_i1 = ".#..\n.#..\n.#..\n...#\n";

	//char *g_rshape_v2 = ".##.\n..##\n....\n....\n";
	//char *g_rshape_i2 = ".#.#\n..##\n....\n....\n";
	
	//char *g_rshape_v3 = "##..\n##..\n....\n....\n";

	t_point **points;

	points = (t_point **)ft_memalloc(sizeof(*points) * 2);
	ck_assert_int_eq(1, validate_tetrimino(g_rshape_v1, &points));
	ck_assert_int_eq(1, xy_to_len(points[0]->x, points[0]->y));
	ck_assert_int_eq(16, xy_to_len(points[1]->x, points[1]->y));
	ck_assert_int_eq(1, points[0]->x);
	ck_assert_int_eq(0, points[0]->y);
	ck_assert_int_eq(1, points[1]->x);
	ck_assert_int_eq(3, points[1]->y);
	free_minmax_points(&points);
	ck_assert_ptr_eq(0, points);

	points = (t_point **)ft_memalloc(sizeof(*points) * 2);
	ck_assert_int_eq(1, validate_tetrimino(g_rshape_v2, &points));
	ck_assert_int_eq(1, xy_to_len(points[0]->x, points[0]->y));
	ck_assert_int_eq(8, xy_to_len(points[1]->x, points[1]->y));
	ck_assert_int_eq(1, points[0]->x);
	ck_assert_int_eq(0, points[0]->y);
	ck_assert_int_eq(3, points[1]->x);
	ck_assert_int_eq(1, points[1]->y);
	free_minmax_points(&points);
	ck_assert_ptr_eq(0, points);

	points = (t_point **)ft_memalloc(sizeof(*points) * 2);
	ck_assert_int_eq(1, validate_tetrimino(g_rshape_v3, &points));
	ck_assert_int_eq(0, points[0]->x);
	ck_assert_int_eq(0, points[0]->y);
	ck_assert_int_eq(1, points[1]->x);
	ck_assert_int_eq(1, points[1]->y);
	ck_assert_int_eq(0, xy_to_len(points[0]->x, points[0]->y));
	ck_assert_int_eq(6, xy_to_len(points[1]->x, points[1]->y));
	free_minmax_points(&points);
	ck_assert_ptr_eq(0, points);

	points = (t_point **)ft_memalloc(sizeof(*points) * 2);
	ck_assert_int_eq(-1, validate_tetrimino(g_rshape_i1, &points));
	ck_assert_ptr_eq(points, 0);

	points = (t_point **)ft_memalloc(sizeof(*points) * 2);
	ck_assert_int_eq(-1, validate_tetrimino(g_rshape_i2, &points));
	ck_assert_ptr_eq(0, points);

#test check_create_tetrimno_shape
	printf("CHECKING CREATE TETRIMNO SHAPE...\n");

	int row;
	char *empty_2_2[] = {"..", ".."};
	char *empty_4_1[] = {".", ".", ".", "."};
	char **res;
	
	row = 0;
	res = create_tetrimno_shape(2, 2);
	ck_assert_str_eq(empty_2_2[0], res[0]);
	ck_assert_str_eq(empty_2_2[1], res[1]);
	ck_assert_int_eq(2, strlen(res[0]));
	ck_assert_int_eq(2, strlen(res[1]));
	ck_assert_ptr_eq(res[2], NULL);

	row = 0;
	res = create_tetrimno_shape(4, 1);
	ck_assert_str_eq(empty_4_1[0], res[0]);
	ck_assert_str_eq(empty_4_1[1], res[1]);
	ck_assert_str_eq(empty_4_1[2], res[2]);
	ck_assert_str_eq(empty_4_1[3], res[3]);
	ck_assert_int_eq(1, strlen(res[0]));
	ck_assert_int_eq(1, strlen(res[1]));
	ck_assert_int_eq(1, strlen(res[2]));
	ck_assert_int_eq(1, strlen(res[3]));
	ck_assert_ptr_eq(res[4], NULL);

#test check_fill_tetrimno
	printf("CHECKING FILL TETRIMNO...\n");

	t_point *point;
	t_tetri *new;

	point = create_point(0);
	new = (t_tetri *)ft_memalloc(sizeof(*new));
	new->width = 2;
	new->height = 2;
	new->start = point;
	new->shape = create_tetrimno_shape(new->width, new->height);
	fill_tetrimino(g_rshape_v3, 'A', new);
	ck_assert_str_eq(new->shape[0], "AA");
	ck_assert_str_eq(new->shape[1], "AA");
	ck_assert_ptr_eq(new->shape[2], 0);
	free_tetrimno(&new);
	ck_assert_ptr_eq(new, 0);

	point = create_point(1);
	new = (t_tetri *)ft_memalloc(sizeof(*new));
	new->width = 1;
	new->height = 4;
	new->start = point;
	new->shape = create_tetrimno_shape(new->height, new->width);
	fill_tetrimino(g_rshape_v1, 'A', new);
	ck_assert_str_eq(new->shape[0], "A");
	ck_assert_str_eq(new->shape[1], "A");
	ck_assert_str_eq(new->shape[2], "A");
	ck_assert_str_eq(new->shape[3], "A");
	ck_assert_ptr_eq(new->shape[4], 0);
	free_tetrimno(&new);
	ck_assert_ptr_eq(new, 0);

#test check_create_tetrimino
	printf("CHECKING CREATE TETRIMINO...\n");

	//char *g_rshape_v2 = ".##.\n..##\n....\n....\n";

	t_tetri *new;

	new = create_tetrimino(g_rshape_v3, 'A');
	ck_assert_int_eq(2, new->width);
	ck_assert_int_eq(2, new->height);
	ck_assert_int_eq(0, new->start->x);
	ck_assert_int_eq(0, new->start->y);
	ck_assert_str_eq(new->shape[0], "AA");
	ck_assert_str_eq(new->shape[1], "AA");
	ck_assert_ptr_eq(new->shape[2], 0);
	free_tetrimno(&new);
	ck_assert_ptr_eq(new, 0);

	new = create_tetrimino(g_rshape_v1, 'B');
	ck_assert_int_eq(1, new->width);
	ck_assert_int_eq(4, new->height);
	ck_assert_int_eq(1, new->start->x);
	ck_assert_int_eq(0, new->start->y);
	ck_assert_str_eq(new->shape[0], "B");
	ck_assert_str_eq(new->shape[1], "B");
	ck_assert_str_eq(new->shape[2], "B");
	ck_assert_str_eq(new->shape[3], "B");
	ck_assert_ptr_eq(new->shape[4], 0);
	free_tetrimno(&new);
	ck_assert_ptr_eq(new, 0);

	new = create_tetrimino(g_rshape_v2, 'C');
	ck_assert_int_eq(3, new->width);
	ck_assert_int_eq(2, new->height);
	ck_assert_int_eq(1, new->start->x);
	ck_assert_int_eq(0, new->start->y);
	ck_assert_str_eq(new->shape[0], "CC.");
	ck_assert_str_eq(new->shape[1], ".CC");
	ck_assert_ptr_eq(new->shape[2], 0);
	free_tetrimno(&new);
	ck_assert_ptr_eq(new, 0);
